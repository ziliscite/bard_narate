package service

import (
	"context"
	"github.com/ziliscite/bard_narate/subscription/internal/domain"
	"github.com/ziliscite/bard_narate/subscription/internal/repository"
)

type Order struct {
	pr repository.Plan
	tr repository.Transaction
	sr repository.Subscription
}

func NewOrderService(pr repository.Plan, tr repository.Transaction, sr repository.Subscription) Order {
	return Order{
		pr: pr,
		tr: tr,
		sr: sr,
	}
}

func (o *Order) Checkout(ctx context.Context, userID uint64, plan *domain.Plan, discount *float64) (*domain.Transaction, error) {
	// Get the plan from the repository
	//p, err := o.pr.Get(ctx, planID)
	//if err != nil {
	//	return "", err
	//}

	// Get the discount from the repository
	//var dv *float64
	//if discountCode != nil {
	//	d, ok, err := o.dr.ValidateAndGet(ctx, *discountCode, p.ID)
	//	if err != nil {
	//		return "", err
	//	}
	//
	//	if !ok {
	//		return "", domain.ErrInvalidDiscount
	//	}
	//
	//	if d.IsExpired() {
	//		return "", domain.ErrExpiredDiscount
	//	}
	//
	//	if !d.IsActive() {
	//		return "", domain.ErrInActiveDiscount
	//	}
	//
	//	dv = &d.PercentageValue
	//}

	// Get tax and fee -- for now just hardcode it
	tax := 10.0
	fee := 6.0

	// Create a new transaction
	transaction, err := o.tr.New(ctx, userID, plan.ID, plan.Currency.String(), plan.Price, func(tr *domain.Transaction) error {
		return tr.
			ApplyTax(&tax).
			ApplyFee(&fee).
			ApplyDiscount(discount).
			CalculateFinalAmount()
	})
	if err != nil {
		return nil, err
	}

	//total := int64(math.Ceil(t.Total))
	//request := midtrans.SnapTokenRequest{
	//	TransactionDetails: midtrans.TransactionDetails{
	//		OrderID:  t.ID.String(),
	//		GrossAmt: total,
	//	},
	//	Items: []midtrans.ItemDetails{
	//		{
	//			ID:           fmt.Sprintf("%d", p.ID),
	//			Name:         p.Name,
	//			Price:        total,
	//			Qty:          1,
	//			Brand:        "Bard Narate",
	//			Category:     "Services",
	//			MerchantName: "Ziliscite",
	//		},
	//	},
	//}
	//
	//// Call payment gateway to process the payment
	//res, err := o.pg.GetSnapToken(request, t.IdempotencyKey)
	//if err != nil {
	//	return "", err
	//}

	return transaction, nil
}

func (o *Order) Finalize(ctx context.Context, transactionID string) error {
	transaction, order, err := o.tr.GetTransactionAndOrder(ctx, transactionID)
	if err != nil {
		return err
	}

	plan, err := o.pr.Get(ctx, order.PlanID)
	if err != nil {
		return err
	}

	activeSub, err := o.sr.GetActive(ctx, order.UserID)
	if err != nil {
		return err
	}

	newSub, err := domain.NewSubscription(order.UserID, plan.ID)
	if err != nil {
		return err
	}

	transaction.Complete()
	if activeSub != nil && !activeSub.IsExpired() {
		return o.sr.PauseAndCreate(ctx, activeSub, newSub, transaction)
	}

	if activeSub != nil && activeSub.IsExpired() {
		activeSub.Deactivate()
		if err = o.sr.Update(ctx, activeSub.ID, activeSub); err != nil {
			return err
		}
	}

	return o.sr.Create(ctx, newSub, transaction)
}

func (o *Order) Cancel(ctx context.Context, transactionID string) error {
	transaction, err := o.tr.GetTransaction(ctx, transactionID)
	if err != nil {
		return err
	}

	transaction.Cancel()
	return o.tr.Update(ctx, transaction.ID, transaction)
}
